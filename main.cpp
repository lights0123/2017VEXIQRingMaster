#pragma config(Motor,  motor1,          driveMotor,    tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor2,          strafeMotor,   tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor8,          armMotorBackup, tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor10,         rotator,       tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor11,         miniArm,       tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor12,         armMotor,      tmotorVexIQ, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
 * WARNING:
 * This file is saved as a "cpp" file. This does NOT mean that it uses C++! This is because RobotC uses several
 * features of C++, while retaining most of C. For example, C has pointers, but not pass-by-reference (while C++
 * does, via the '&' character). However, RobotC doesn't support pointers, and relies on the '&' character to
 * pass by reference. Because that doesn't exist in normal C, my IDE (CLion) gives me a warning that that doesn't
 * work. I save it as a C++ file so that I can use both RobotC and CLion without errors.
 */


#include "RobotCCompatibility.h"
//Used to allow me to use my preferred IDE (CLion) to program RobotC without syntax errors

#ifndef ROBOTC                    //Also for compatibilty with other IDEs.
#define driveMotor port1
#define strafeMotor port2
#define armMotorBackup port8
#define rotator port10
#define miniArm port11
#define armMotor port12
#endif

/**
 * This is used to keep track of the status of calibration - it locks the motors being calibrated otherwise.
 * It probably isn't needed, but because I'm used to Arduino, I defined it as volatile. This tells the compiler not
 * to optimize it, because it can change elsewhere.
 */
typedef enum {
    DIRECTION_UP,
    DIRECTION_DOWN
} direction;
volatile bool isCalibrating = false;

void individualCalibrate(tMotor motor, direction dir, int endGoal) {
    int encoder;

    /**
     * Used to store if the calibration process was successful or not.
     */
    bool calibrateSuccessful = false;

    while (!calibrateSuccessful) {

        //Bring the motor out to avoid getting stuck
        setMotorSpeed(motor, dir == DIRECTION_DOWN ? 40 : -40);
        delay(300);
        //Stop it
        setMotorSpeed(motor, 0);
        delay(200);
        //Bring it back towards the endstop
        setMotorSpeed(motor, dir == DIRECTION_DOWN ? -80 : 80);
        delay(100);
        //Wait for the motor to stop (i.e. hit something)
        do {
            encoder = getMotorEncoder(motor);
            delay(50);
            //Get the current encoder position, then wait 50ms. If the motor didn't move in that time,
        } while (abs(getMotorEncoder(motor) - encoder) != 0); //end the loop.
        setMotorSpeed(motor, 0);
        delay(100);
        //Reset the motor encoder, because it's at its correct 0 degree position,
        //in which everything is based off of
        resetMotorEncoder(motor);
        //Go to the correct position used for the program
        setMotorTarget(motor, endGoal, dir == DIRECTION_DOWN ? -60 : 60);
        clearTimer(T2);
        //Wait until the motor is at the correct position
        while (true) {
            if (getMotorEncoder(motor) == endGoal) {
                calibrateSuccessful = true;
                break;
            } else if (time1[T2] > 2000) break; // If at least 2 seconds have passed, restart calibration
        }
    }
}
/**
 * This calibrates the flipper and arm motors to their correct positions. This is achieved by jamming the motors
 * into pieces that stop them. Once no movement is detected, the motors return to their correct positions to run.
 * If that process takes longer than 2 seconds, the calibration starts over again.
 */
task calibrate() {
    isCalibrating = true;
    individualCalibrate(miniArm, DIRECTION_UP, -5);
    isCalibrating = false;
}

//Vex Joystick Channels:

//ChA: Left Joystick, Y-axis
//ChB: Left Joystick, X-axis
//ChC: Right Joystick, X-axis
//ChD: Right Joystick, Y-axis
/**
 * The left joystick will control forwards & backwards movement, by moving the joystick forwards and backwards.
 * The right joystick will control left & right movement, by moving the joystick left and right.
 */
task wheelControl() {
    while (true) {
        int straightPower = getJoystickValue(ChA);
        int strafePower = getJoystickValue(ChC);
        setMotorSpeed(driveMotor, straightPower);
        setMotorSpeed(strafeMotor, strafePower);
    }
}

bool ringDetected = false;
int ringCount = 0;

task main() {
    startTask(calibrate);
    startTask(wheelControl);

    while (isCalibrating);

    while(true){
    	if (getJoystickValue(BtnLUp)) setMotorTarget(miniArm, -100, 100);
			else if (getJoystickValue(BtnLDown)) setMotorTarget(miniArm, 20, 100);

    	if (getJoystickValue(BtnRUp)){
    		setMotorSpeed(armMotor, -100);
    		setMotorSpeed(armMotorBackup, -100);
    	}
			else if (getJoystickValue(BtnRDown)){
				setMotorSpeed(armMotor, 50);
				setMotorSpeed(armMotorBackup, 50);
			}
			else{
				setMotorTarget(armMotor,getMotorEncoder(armMotor),100);
				setMotorTarget(armMotorBackup,getMotorEncoder(armMotorBackup),100);
			}

    	if (getJoystickValue(BtnEUp)) setMotorSpeed(rotator, -20);
			else if (getJoystickValue(BtnEDown)) setMotorSpeed(rotator, 20);
			else{
				setMotorTarget(rotator,getMotorEncoder(rotator),100);
			}
  	}
}
