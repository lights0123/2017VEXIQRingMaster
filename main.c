#pragma config(Motor,  motor6,          leftMotor,     tmotorVexIQ, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//ChA: Left Joystick, Y-axis
//ChB: Left Joystick, X-axis
//ChC: Right Joystick, X-axis
//ChD: Right Joystick, Y-axis
typedef struct{
	int left, right;
} TMotorControl;

//https://robotics.stackexchange.com/a/2016
TMotorControl angleToThrust(int r, int theta){
	TMotorControl t;
	theta = ((theta + 180) % 360) - 180;			// normalize value to [-180, 180)
	if(r > 100) r = 100;							// normalize value to [0, 100]
		int v_a = r * (45 - theta % 90) / 45;		// falloff of main motor
	int v_b = min(100, 2 * r + v_a, 2 * r - v_a);	// compensation of other motor
	if(theta < -90){
		t.left = -v_b;t.right= -v_a;
	}else if (theta < 0){
		t.left = -v_a;t.right=v_b;
	}else if(theta < 90){
		t.left= v_b;t.right=v_a;
	}else{
		t.left=v_a;t.right=-v_b;
	}
	return t;
}
task main()
{
	while(true){
		int x = getJoystickValue(ChB);
		int y = getJoystickValue(ChA);
		//https://stackoverflow.com/questions/40363809/faster-way-to-go-from-cartesian-to-polar-in-c
		float radius, angle;
		radius = sqrt( x*x + y*y);
		angle = radiansToDegrees(atan2(y, x));
		TMotorControl t = angleToThrust(radius,angle);
		displayTextLine(1, "Left: %d", t.left);
		displayTextLine(2, "Right: %d", t.right);
	}
}
